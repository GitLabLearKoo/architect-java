# Java设计模式之创建型模式

## 工厂模式【Factory】

定义：工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。

普通工厂：工厂是具体的，产品是抽象的。【学习难度：★★☆☆☆，使用频率：★★★★★】

![](https://img-blog.csdn.net/20171228173655000)
 

抽象工厂：工厂是抽象的，产品是抽象的。【学习难度：★★★★☆，使用频率：★★★★★】

![](https://img-blog.csdn.net/20171228173926388)


对比工厂模式和抽象工厂模式：

1.工厂模式对产品Product进行了抽象，通过传递ProductType进行动态构造Product。

【比较常用】

2.抽象工厂在工厂模式上，又对工厂进行了抽象，抽象了工厂制造提供产品的行为，这样就可以动态设置不同的工厂，生产多种不同品类的产品。

【剥离工厂与产品之前的耦合，便于扩展】


---


## 单例模式【Singleton】

> 【学习难度：★☆☆☆☆，使用频率：★★★★☆】

定义：通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。

单例模式应该说是最常见的一种设计模式了。



主要优点：

1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。

2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。

3、有些类如打印机，全局只需要一个或者一种打印机的。



主要缺点：

1、由于单利模式中没有抽象层，耦合性太强，因此单例类的扩展有很大的困难。

2、单例类的职责过重，在一定程度上违背了“单一职责原则”。

3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。



因此，在使用单例之前，一定要三思而后行。

---

## 建造者模式【Builder】

>【学习难度：★★★★☆，使用频率：★★☆☆☆】

定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

 ![](https://img-blog.csdn.net/20171228174040080)
 

构建者类似工厂模式，但是区别在于：建造者模式注重零部件的组装过程【具体的创建在产品内部创建】，而工厂方法模式更注重零部件的创建过程。



使用建造者模式的好处：

1.使用建造者模式可以使客户端不必知道产品内部组成的细节（不需要非常多的构造函数）。

2.具体的建造者类之间是相互独立的，对系统的扩展非常有利。

3.由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

使用建造模式的场合：

1.创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。

2.要创建的复杂对象的算法，独立于该对象的组成部分，也独立于组成部分的装配方法时。


---


## 原型模式【Prototype】

>【学习难度：★★★☆☆，使用频率：★★★☆☆】

定义：该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。

使用场景：

（1）在进行网络请求的时候，一些全局性的配置，例如：baseUrl、timeout、retryCount、cacheMode、Interceptor等，我们不希望每次进行网络请求的时候都进行设置，就可以将这些配置存放在一个单例中，每次创建网络请求的时候，在构造方法里先复制拷贝这些全局属性，然后在网络请求里面提供动态设置这些属性的方法，这样就可以省去很多设置操作，从而实现全局配置，动态变化。

（2）在JS里面，对象的继承就是使用原型模式实现的（没有extends），ES6之后才引入了extends。


