# Java设计模式

## Java设计的七大原则

设计原则名称 | 定  义 | 使用频率
:-|:-:|:-
单一职责原则(Single Responsibility Principle, SRP) | 一个类只负责一个功能领域中的相应职责。| ★★★★☆
开闭原则(Open-Closed Principle, OCP) | 软件实体应对扩展开放，而对修改关闭。`开闭原则的关键在于抽象化`。| ★★★★★
里氏代换原则(Liskov Substitution Principle, LSP) | 所有引用基类对象的地方能够透明地使用其子类的对象【子类不应该覆盖父类的非抽象方法】。`里氏代换原则是实现开闭原则的重要方式之一` | ★★★★★
依赖倒转原则(Dependence  Inversion Principle, DIP) | 抽象不应该依赖于细节，细节应该依赖于抽象。`是开闭原则的基础。【可以通过依赖注入的方式实现】` | ★★★★★
接口隔离原则(Interface Segregation Principle, ISP) | 使用多个专门的接口，而不使用单一的总接口。`【需要把控好接口的粒度】` | ★★☆☆☆
合成复用原则(Composite Reuse Principle, CRP) | 复用时要尽量使用组合/聚合关系（关联关系），少用继承。  | ★★★★☆
迪米特法则（最少知道）(Law of Demeter, LoD) | 一个软件实体应当尽可能少地与其他实体发生相互作用。 | ★★★☆☆


### 里氏代换原则

里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。需要注意以下几点：

（1）子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。

（2）尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。

（3）子类不应该覆盖父类的非抽象方法（可以重载，但一定要调父类的方法）。



### 依赖倒转原则

在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，`依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象`。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。

（1）构造注入是指通过构造函数来传入具体类的对象。

（2）设值注入是指通过Setter方法来传入具体类的对象。

（3）接口注入是指通过在接口中声明的业务方法来传入具体类的对象。

这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

`开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。`


### 接口隔离原则

（1）在使用接口隔离原则时，我们需要`注意控制接口的粒度`。

（2）接口不能太小。如果太小会导致系统中接口泛滥，不利于维护；

（3）接口也不能太大。太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。

一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。


### 合成复用原则

`通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性`。因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性。

一般而言，`如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承`。"Is-A"是严格的分类学意义上的定义，意思是一个类是另一个类的"一种"；而"Has-A"则不同，它表示某一个角色具有某一项责任。


## Java设计模式详解

* [Java设计模式之创建型模式](./creation/README.md)

* [Java设计模式之结构型模式](./structure/README.md)

* [Java设计模式之行为型模式](./creation/README.md)
